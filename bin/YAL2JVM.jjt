options{	LOOKAHEAD = 1;}PARSER_BEGIN(YAL2JVM)import java.io.FileInputStream;import java.io.FileNotFoundException;
public class YAL2JVM{   private static Module module;   private static int numErrors = 0;   private static boolean hasErrors = true;   private static Generator generator;	   public static void main(String args [])   {		if(args.length < 1)		{			System.out.println("Usage: java YAL2JVM <filename>.yal");			return;		}		if(args.length == 2)		{			if(args[1].equals("-r") || args[1].equals("-o"))		  		System.out.println("A opção -r e -o ainda não foram implementadas.");		  	else		  		System.out.println("A opção "+args[1]+" não é reconhecida pelo YAL2JVM.");		}    	YAL2JVM myYAL2JVM = null;		try		{			myYAL2JVM = new YAL2JVM(new FileInputStream(args[0]));		}		catch (FileNotFoundException e1)		{			e1.printStackTrace();		}    	SimpleNode root = null;		try		{			root = myYAL2JVM.Module();			module = new Module(root.ID, root);		}		catch (ParseException e)		{			e.printStackTrace();		}				System.out.println("\n");		System.out.println("Módulo a analisar "+root.ID+"\n");		Utils.getGlobalVariables(root,module);    	//root.dump("");    	root.analyse();    	    	System.out.println("O módulo "+root.ID+" tem "+numErrors+" erros!");    	    	Utils.getFunctions(root,module);    	System.out.println("============================");    	module.processFunctions();    	System.out.println("============================");    	module.printAllModule();    	if(hasErrors)    	{    	  System.out.println("A Iniciar o Gerador JVM: ");    	  generator = new Generator(module,root.ID,root);    	  generator.initiateGeneration();    	  System.out.println("A geração de código JVM foi concluida com sucesso.");   		}   		else   		{   		  System.out.println("O módulo " + root.ID + " possui erros semanticos.");   		  System.out.println("Não é por isso possível gerar o código JVM.");   		}   }   public static Module getModule()   {		return module;   }   public static void incErrors()   {     	numErrors++;   }   public static void errorFound()   {     	hasErrors = true;   }}PARSER_END(YAL2JVM)<DEFAULT> SKIP:{	" "	| "\t"	| "\n"	| "\r"	| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>	| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">}/* reserved words */<DEFAULT> TOKEN :{	<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">	| <ADDSUB_OP: "+" | "-">	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">	| <BITWISE_OP: "&" | "|" | "^">	| <NOT_OP: "!">	| <WHILE: "while">	| <IF: "if">	| <ELSE: "else">	| <ASSIGN: "=">	| <ASPA: "\"">	| <LPAR: "(">	| <RPAR: ")">	| <VIRG: ",">	| <PVIRG: ";">	| <LCHAVETA: "{">	| <RCHAVETA: "}">	| <FUNCTION: "function">	| <MODULE: "module">	| <SIZE: "size">}<DEFAULT> TOKEN :{	<INTEGER: (<DIGIT>)+>	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>	| <#LETTER: ["$","A"-"Z","_","a"-"z"]>	| <#DIGIT: ["0"-"9"]>	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">}SimpleNode Module() #Module: { Token moduleId; }{	< MODULE > moduleId = < ID > { jjtThis.ID = moduleId.image; } <LCHAVETA >	( Declaration())* (Function())* < RCHAVETA >   	{ return jjtThis; }}void Declaration() #Declaration: { Token assign; }{	LeftSide() (assign=<ASSIGN> { jjtThis.ID = assign.image; } RightSide())? <PVIRG>}void LeftSide() #void: {}{	LOOKAHEAD(2) ArrayElement() | ScalarElement()}void Function() #Function: { Token functionID; }{	<FUNCTION> (LOOKAHEAD(3) Return())? functionID=<ID> {		jjtThis.ID = functionID.image;	} <LPAR> (Varlist())? <RPAR> <LCHAVETA> FunctionBody() <RCHAVETA>}void Return() #Return: {}{	(LOOKAHEAD(2) ArrayElement() | ScalarElement()) <ASSIGN>}void Varlist() #Varlist: {}{	(LOOKAHEAD(2) ArrayElement() | ScalarElement()) (<VIRG> (LOOKAHEAD(2) ArrayElement() | ScalarElement()))*}void ArrayElement() #Array: { Token arrayId; }{	arrayId=<ID> {jjtThis.ID = arrayId.image;} "[" "]"}void ScalarElement() #Scalar: { Token scalarId; }{	scalarId=<ID> {jjtThis.ID = scalarId.image;}}void Stmtlst() #void: {}{	(Stmt())*}void Stmt() #void: {}{	While() | If() | LOOKAHEAD(3) Assign() | Call() <PVIRG>}void Assign() #Assignement: {}{	Lhs() <ASSIGN> Rhs() <PVIRG>}void Lhs() #Lhs: {}{	LOOKAHEAD(2) ArrayAccess() | ScalarAccess()}void Rhs() #Rhs: {Token op;}{	(Term() ((op=<ARITH_OP> {jjtThis.ID = op.image;} |			 op=<BITWISE_OP> {jjtThis.ID = op.image;} |			 op=<ADDSUB_OP> {jjtThis.ID = op.image;}) Term())?) |			 "[" ArraySize() "]"}void RightSide() #RightSide: { Token op, intID; }{	("[" ArraySize() "]")  | 	((op=<ADDSUB_OP> {jjtThis.ID = op.image;})?	intID=<INTEGER> {		if (jjtThis.ID != null)			jjtThis.ID += intID.image;		else			jjtThis.ID = intID.image;	})}void ArraySize() #ArraySize: { Token intId; }{	ScalarAccess() | intId=<INTEGER> { jjtThis.ID = intId.image; }}void Term() #Term: { Token op, intId; }{	(op=<ADDSUB_OP> {jjtThis.ID = op.image;})?	(intId=<INTEGER>	{		if (jjtThis.ID != null)			jjtThis.ID += intId.image;		else			jjtThis.ID = intId.image;	}	| LOOKAHEAD(3) Call() | LOOKAHEAD(2) ArrayAccess() | ScalarAccess())}void Exprtest() #Exprtest: { Token op; }{	< LPAR > Lhs() op= <RELA_OP> { jjtThis.ID = op.image; } Rhs() <RPAR>}void While() #While: {}{	<WHILE> Exprtest() <LCHAVETA> WhileBody() <RCHAVETA>}void If() #If: {}{	<IF> Exprtest() <LCHAVETA> IfBody() <RCHAVETA> (<ELSE> <LCHAVETA> ElseBody() <RCHAVETA>)?}void Call() #Call: { Token id, callID; }{	id=<ID> {jjtThis.ID = id.image;} ("." callID=<ID> {jjtThis.ID += "." + callID.image; })?	<LPAR> (ArgumentList())? <RPAR>}void ArgumentList() #void: {}{	Argument() (<VIRG> Argument())*}void Argument() #Argument: { Token arg; }{	arg=<ID> {jjtThis.ID = arg.image;}	| arg=<STRING> {jjtThis.ID = arg.image;}	| arg=<INTEGER> {	jjtThis.ID = arg.image;}}void ArrayAccess() #ArrayAccess: { Token arrayID; }{	arrayID=<ID> { jjtThis.ID = arrayID.image; } "[" Index() "]"}void ScalarAccess() #ScalarAccess: { Token scalarID, size; }{	scalarID=<ID> {jjtThis.ID = scalarID.image;}	("." size=<SIZE> {jjtThis.ID += "." + size.image;})?}void Index() #Index: { Token id, intID; }{	id=<ID> {jjtThis.ID = id.image;} | intID=<INTEGER> {jjtThis.ID = intID.image;}}void FunctionBody() #FunctionBody: {}{	Stmtlst()}void WhileBody() #WhileBody: {}{	Stmtlst()}void IfBody() #IfBody: {}{	Stmtlst()}void ElseBody() #ElseBody: {}{	Stmtlst()}